////////////////////////////////////////////////////////////////////////////////

// Clean and trim amplicon reads seqeunced on Illumina MiSeq (2x 300bp)
// Input FASTQ reads must have Sanger quality scores and be labelled by sample.
// Note: the code for calculating sequence statistics assumes that the sequences
// are NOT wrapped.
// Usage example: bpipe run pipeline_QA.groovy sediments.fastq

// Options:

// Quality score from which to start truncating the 3' end of a read
TRIM_QUAL=13
// e.g. if you pick 16, all quality scores will be >=17 after truncation
// Q20: 1% , Q19: 1.3%, Q18: 1.6%, Q17: 2%, Q16: 2.5%, Q15: 3.2%, Q14: 4%, Q13: 5%
// Ambiguities such as N typically have Q0. A Q13 threshold will essentially
// eliminate Ns and other low quality bases from the reads.

// Filter out reads with over this % of expected errors (based on quality scores)
EE_PERC=3.0

// Flag to perform or skip the Acacia denoising step
SKIP_DENOISING=0

// Read trimming/discard length
TRIM_LEN=250
// 250bp captures the whole V6-V7 region using the ACE 926F-1392R primers (V6-V8)
// TODO: Not true, since we sequence from the REVERSE primer!

////////////////////////////////////////////////////////////////////////////////


//////////
// TODO
// * Use very clean reads (trim_qual and ee_filt) to determine OTUs,
//   but try to classify even not so clean reads (ee_filt only) into OTUs.
//   This means implementing ee_filt before trim_qual, saving READS into variable
//////////


about title: "hitman_deploy_miseq - Quality assurance for Illumina MiSeq amplicons"


Bpipe.run {
   fastq_stats.using(stage:'initial') +
   merge_read_pairs() + ///// IMPLEMENT ME
   fastq_stats.using(stage:'merge') +
   rm_small_fastq.using(length:TRIM_LEN-10) +
   fastq_stats.using(stage:'discard') +
   qual_trim_fastq.using(qual:TRIM_QUAL) +
   fastq_stats.using(stage:'qtrim') +
   rm_small_fastq.using(length:TRIM_LEN-10) +
   fastq_stats.using(stage:'qdiscrd') +
   trim_fastq.using(length:TRIM_LEN+10) +
   fastq_stats.using(stage:'trim') +
   ee_filter.using(ee:TRIM_LEN*EE_PERC/100) +
   fastq_stats.using(stage:'eefilt') +
   rm_small_fasta.using(length:TRIM_LEN) +
   fasta_stats.using(stage:'fdiscrd') +
   trim_fasta.using(length:TRIM_LEN) +
   fasta_stats.using(stage:'ftrim') +
   final_report
}
