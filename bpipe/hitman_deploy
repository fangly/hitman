////////////////////////////////////////////////////////////////////////////////

// Clean and trim amplicon reads sequenced on 454 GS-FLX Ti (~1x 500bp) or
// Illumina MiSeq (2x 300bp)

// Input FASTQ reads must have Sanger quality scores and be labelled by sample.
// Note: the code for calculating sequence statistics assumes that the sequences
// are NOT wrapped.
// Usage example: bpipe run pipeline_QA.groovy sediments.fastq

// Options:

// Flag to skip the computation of sequence statistics
SKIP_STATS=0

//// Quality score from which to start truncating the 3' end of a read
//TRIM_QUAL=13
TRIM_QUAL=14
// e.g. if you pick 16, all quality scores will be >=17 after truncation
// Q20: 1% , Q19: 1.3%, Q18: 1.6%, Q17: 2%, Q16: 2.5%, Q15: 3.2%, Q14: 4%, Q13: 5%
// Ambiguities such as N typically have Q0. A Q13 threshold will essentially
// eliminate Ns and other low quality bases from the reads.

// Filter out reads with over this % of expected errors (based on quality scores)
EE_PERC=3.0

// Flag to skip the Acacia denoising step
SKIP_DENOISING=0

// Read trimming/discard length
TRIM_LEN=250
// 250bp captures the whole V6-V7 region using the ACE 926F-1392R primers (V6-V8)
// TODO: Not true, since we sequence from the REVERSE primer!

////////////////////////////////////////////////////////////////////////////////


//////////
// TODO
// * Use very clean reads (trim_qual and ee_filt) to determine OTUs,
//   but try to classify even not so clean reads (ee_filt only) into OTUs.
//   This means implementing ee_filt before trim_qual, saving READS into variable
//////////


about title: "hitman_deploy - Quality assurance for amplicons reads"


Bpipe.run {
   seq_stats.using(stage:'initial', skip:SKIP_STATS) +
   rm_small_seqs.using(length:TRIM_LEN-10) +
   seq_stats.using(stage:'discard', skip:SKIP_STATS) +
   qual_trim_seqs.using(qual:TRIM_QUAL) +
   seq_stats.using(stage:'qtrim', skip:SKIP_STATS) +
   rm_small_seqs.using(length:TRIM_LEN-10) +
   seq_stats.using(stage:'qdiscrd', skip:SKIP_STATS) +
   trim_seqs.using(length:TRIM_LEN+10) +
   seq_stats.using(stage:'trim', skip:SKIP_STATS) +
   ee_filter.using(ee:TRIM_LEN*EE_PERC/100) +
   seq_stats.using(stage:'eefilt', skip:SKIP_STATS) +
   acacia.using(skip:SKIP_DENOISING) +
   fasta2fastq +
   seq_stats.using(stage:'acacia', skip:SKIP_STATS) +
   rm_small_seqs.using(length:TRIM_LEN) +
   seq_stats.using(stage:'fdiscrd', skip:SKIP_STATS) +
   trim_seqs.using(length:TRIM_LEN) +
   seq_stats.using(stage:'ftrim', skip:SKIP_STATS) +
   fastq2fasta +
   final_report
}
